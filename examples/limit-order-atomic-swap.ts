import { ethers } from 'ethers';
import { JsonRpcProvider } from '@ethersproject/providers';
import * as crypto from 'crypto';
import { SuiClient, SuiTransactionBlockResponse } from '@mysten/sui/client';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { Transaction } from '@mysten/sui/transactions';
import { getFullnodeUrl } from '@mysten/sui/client';
import { bcs } from '@mysten/sui/bcs';
import dotenv from 'dotenv';

dotenv.config();

// Load configuration
const config = JSON.parse(require('fs').readFileSync('./config.json', 'utf8'));

// Limit Order Escrow ABI
const LIMIT_ORDER_ESCROW_ABI = [
    "function createAtomicSwapOrder(bytes32 orderId, address taker, address makerAsset, address takerAsset, uint256 makerAmount, uint256 takerAmount, bytes32 hashlock, uint256 timelock, bytes calldata orderData, bytes calldata signature) external payable",
    "function fillAtomicSwapOrder(bytes32 orderId, bytes32 secret, bytes calldata interaction, uint256 makingAmount, uint256 takingAmount, uint256 thresholdAmount) external",
    "function refundAtomicSwapOrder(bytes32 orderId) external",
    "function getAtomicSwapOrder(bytes32 orderId) external view returns (bytes32, bytes32, uint256, address, address, address, address, uint256, uint256, bytes32, bool, bool, uint256)",
    "function getRevealedSecret(bytes32 orderId) external view returns (bytes32)",
    "function authorizeRelayer(address relayer) external",
    "event AtomicSwapOrderCreated(bytes32 indexed orderId, address indexed maker, address indexed taker, address makerAsset, address takerAsset, uint256 makerAmount, uint256 takerAmount, bytes32 hashlock, uint256 timelock)",
    "event AtomicSwapOrderFilled(bytes32 indexed orderId, address indexed taker, bytes32 secret, uint256 makerAmount, uint256 takerAmount)",
    "event AtomicSwapOrderRefunded(bytes32 indexed orderId, address indexed maker, uint256 makerAmount)"
];

interface SwapOrder {
    orderId: string;
    secret: string;
    hashlock: string;
    ethTimelock: number;
    suiTimelock: number;
    makerAsset: string;
    takerAsset: string;
    makerAmount: string;
    takerAmount: string;
    orderData: string;
    signature: string;
}

class LimitOrderAtomicSwap {
    private ethProvider: JsonRpcProvider;
    private ethWallet: ethers.Wallet;
    private ethContract: ethers.Contract;
    private suiClient: SuiClient;
    private suiKeypair: Ed25519Keypair;

    constructor() {
        // Initialize Ethereum
        this.ethProvider = new JsonRpcProvider(config.ethereum.rpc);
        this.ethWallet = new ethers.Wallet(config.ethereum.privateKey, this.ethProvider);
        this.ethContract = new ethers.Contract(
            config.ethereum.limitOrderEscrowAddress,
            LIMIT_ORDER_ESCROW_ABI,
            this.ethWallet
        );

        // Initialize Sui
        this.suiClient = new SuiClient({ url: getFullnodeUrl('mainnet') });
        const privateKey = config.sui.privateKey.endsWith('1b') ? 
            config.sui.privateKey.slice(0, -2) : config.sui.privateKey;
        this.suiKeypair = Ed25519Keypair.fromSecretKey(Buffer.from(privateKey, 'hex'));
        
        console.log("ğŸ”— Limit Order Atomic Swap initialized");
        console.log(`ğŸ“ ETH Address: ${this.ethWallet.address}`);
        console.log(`ğŸ“ SUI Address: ${this.suiKeypair.getPublicKey().toSuiAddress()}`);
    }

    getSuiAddress(): string {
        return this.suiKeypair.getPublicKey().toSuiAddress();
    }

    private generateSwapOrder(): SwapOrder {
        const secret = crypto.randomBytes(32);
        const hashlock = crypto.createHash('sha256').update(secret).digest();
        const orderId = crypto.randomBytes(16).toString('hex');
        const ethTimelock = Math.floor(Date.now() / 1000) + 7200; // 2 hours
        const suiTimelock = Math.floor(Date.now() / 1000) + 3600; // 1 hour

        // Generate mock 1inch order data and signature
        // In production, this would be generated by the 1inch SDK
        const orderData = "0x" + crypto.randomBytes(100).toString('hex');
        const signature = "0x" + crypto.randomBytes(65).toString('hex');

        return {
            orderId,
            secret: "0x" + secret.toString('hex'),
            hashlock: "0x" + Buffer.from(hashlock).toString('hex'),
            ethTimelock,
            suiTimelock,
            makerAsset: config.ethereum.weth, // WETH as maker asset
            takerAsset: "0x0000000000000000000000000000000000000000", // ETH as taker asset
            makerAmount: ethers.utils.parseEther("0.00001").toString(), // 0.001 WETH
            takerAmount: ethers.utils.parseEther("0.00001").toString(), // 0.001 ETH
            orderData,
            signature
        };
    }

    async createEthereumAtomicSwapOrder(
        orderId: string,
        takerAddress: string,
        hashlock: string,
        timelock: number,
        makerAsset: string,
        takerAsset: string,
        makerAmount: string,
        takerAmount: string,
        orderData: string,
        signature: string
    ) {
        console.log("ğŸ”— Creating Ethereum Atomic Swap Order...");
        console.log(`ğŸ“ Order ID: ${orderId}`);
        console.log(`ğŸ’° Maker Amount: ${ethers.utils.formatEther(makerAmount)} WETH`);
        console.log(`ğŸ’° Taker Amount: ${ethers.utils.formatEther(takerAmount)} ETH`);
        console.log(`â° Timelock: ${new Date(timelock * 1000).toISOString()}`);
        
        // First approve WETH spending
        const wethContract = new ethers.Contract(
            config.ethereum.weth,
            ["function approve(address spender, uint256 amount) external returns (bool)"],
            this.ethWallet
        );
        
        console.log("ğŸ”“ Approving WETH spending...");
        const approveTx = await wethContract.approve(
            config.ethereum.limitOrderEscrowAddress,
            makerAmount,
            { gasLimit: 100000 }
        );
        await approveTx.wait();
        console.log("âœ… WETH approved");
        
        const tx = await this.ethContract.createAtomicSwapOrder(
            ethers.utils.id(orderId),
            takerAddress,
            makerAsset,
            takerAsset,
            makerAmount,
            takerAmount,
            hashlock,
            timelock,
            orderData,
            signature,
            { gasLimit: 500000 }
        );
        
        console.log(`â³ Transaction pending: ${tx.hash}`);
        const receipt = await tx.wait();
        
        console.log("âœ… Ethereum Atomic Swap Order created successfully!");
        console.log(`ğŸ”— Transaction Hash: ${receipt.transactionHash}`);
        console.log(`ğŸ” Explorer: https://sepolia.etherscan.io/tx/${receipt.transactionHash}`);
        console.log(`â›½ Gas Used: ${receipt.gasUsed.toString()}`);
        
        return receipt;
    }

    async createSuiHTLC(htlcId: string, receiverAddress: string, hashlock: string, timelock: number, amount: string) {
        console.log("\nğŸ”— Creating Sui HTLC...");
        console.log(`ğŸ“ HTLC ID: ${htlcId}`);
        console.log(`ğŸ’° Amount: ${amount} SUI`);
        console.log(`â° Timelock: ${new Date(timelock * 1000).toISOString()}`);
        
        const senderAddress = this.suiKeypair.getPublicKey().toSuiAddress();
        console.log(`ğŸ‘¤ Receiver: ${receiverAddress}`);
        
        // Get coins for payment
        const coins = await this.suiClient.getCoins({
            owner: senderAddress,
            coinType: "0x2::sui::SUI"
        });
        
        if (!coins || coins.data.length === 0) {
            throw new Error("âŒ No SUI coins found in wallet");
        }

        const tx = new Transaction();
        const amountInMist = Math.floor(parseFloat(amount) * 1e9);
        const [paymentCoin] = tx.splitCoins(tx.gas, [tx.pure.u64(amountInMist)]);

        const htlcIdBytes = Array.from(Buffer.from(htlcId));
        const hashlockBytes = Array.from(Buffer.from(hashlock.slice(2), 'hex'));
        const receiverAddr = receiverAddress.replace('0x', '');

        tx.moveCall({
            target: `${config.sui.packageId}::htlc::create_htlc`,
            arguments: [
                tx.object.clock(),
                tx.pure.vector('u8', htlcIdBytes),
                tx.pure.address(receiverAddr),
                tx.pure.vector('u8', hashlockBytes),
                tx.pure.u64(timelock),
                paymentCoin
            ]
        });

        const result = await this.suiClient.signAndExecuteTransaction({
            signer: this.suiKeypair,
            transaction: tx,
            options: { 
                showEffects: true,
                gasBudget: 100000000
            }
        });
        
        console.log("âœ… Sui HTLC created successfully!");
        console.log(`ğŸ”— Transaction Hash: ${result.digest}`);
        console.log(`ğŸ” Explorer: https://suiexplorer.com/txblock/${result.digest}?network=testnet`);
        
        return result;
    }

    async fillAtomicSwapOrder(
        orderId: string,
        secret: string,
        interaction: string,
        makingAmount: string,
        takingAmount: string,
        thresholdAmount: string
    ) {
        console.log("ğŸ”“ Filling Atomic Swap Order...");
        console.log(`ğŸ“ Order ID: ${orderId}`);
        console.log(`ğŸ” Secret: ${secret}`);
        console.log(`ğŸ’° Taking Amount (ETH): ${ethers.utils.formatEther(takingAmount)}`);
        
        const tx = await this.ethContract.fillAtomicSwapOrder(
            ethers.utils.id(orderId),
            secret,
            interaction,
            makingAmount,
            takingAmount,
            thresholdAmount,
            { 
                value: takingAmount, // Send ETH as taker
                gasLimit: 500000 
            }
        );
        
        console.log(`â³ Transaction pending: ${tx.hash}`);
        const receipt = await tx.wait();
        
        console.log("âœ… Atomic Swap Order filled successfully!");
        console.log(`ğŸ”— Transaction Hash: ${receipt.transactionHash}`);
        console.log(`ğŸ” Explorer: https://sepolia.etherscan.io/tx/${receipt.transactionHash}`);
        
        return receipt;
    }

    async claimSuiHTLC(htlcId: string, secret: string, hashlock: string, htlcTxDigest: string) {
        console.log("ğŸ”“ Claiming Sui HTLC...");
        console.log(`ğŸ“ HTLC ID: ${htlcId}`);
        console.log(`ğŸ” Secret: ${secret}`);
        
        const tx = new Transaction();
        
        // Get HTLC object from transaction
        const htlcTx = await this.suiClient.getTransactionBlock({
            digest: htlcTxDigest,
            options: {
                showEffects: true,
                showObjectChanges: true
            }
        });

        const htlcObject = htlcTx.objectChanges.find(change => 
            change.type === 'created' && 
            change.objectType.includes('::htlc::HTLC')
        );

        if (!htlcObject) {
            throw new Error("âŒ HTLC object not found in transaction");
        }

        const secretBytes = Array.from(Buffer.from(secret.slice(2), 'hex'));
        
        tx.moveCall({
            target: `${config.sui.packageId}::htlc::claim_with_secret`,
            arguments: [
                tx.object.clock(),
                tx.object(htlcObject.objectId),
                tx.pure.vector('u8', secretBytes)
            ]
        });
        
        const result = await this.suiClient.signAndExecuteTransaction({
            signer: this.suiKeypair,
            transaction: tx,
            options: { 
                showEffects: true,
                gasBudget: 100000000
            }
        });
        
        console.log("âœ… Sui HTLC claimed successfully!");
        console.log(`ğŸ”— Transaction Hash: ${result.digest}`);
        console.log(`ğŸ” Explorer: https://suiexplorer.com/txblock/${result.digest}?network=testnet`);
        
        return result;
    }

    async performLimitOrderAtomicSwap(
        ethAmount: string,
        suiAmount: string,
        ethReceiverAddress: string,
        suiReceiverAddress: string
    ): Promise<boolean> {
        try {
            console.log("\nğŸš€ Starting Limit Order Atomic Swap...");
            console.log("=====================================");
            console.log(`ğŸ’° ETH Amount: ${ethAmount}`);
            console.log(`ğŸ’° SUI Amount: ${suiAmount}`);
            console.log(`ğŸ‘¤ ETH Receiver: ${ethReceiverAddress}`);
            console.log(`ğŸ‘¤ SUI Receiver: ${suiReceiverAddress}`);
            console.log("=====================================\n");
            
            // Generate swap order with 1inch integration
            const swapOrder = this.generateSwapOrder();
            console.log("ğŸ² Generated swap order:");
            console.log(`ğŸ“ Order ID: ${swapOrder.orderId}`);
            console.log(`ğŸ” Hashlock: ${swapOrder.hashlock}`);
            console.log(`ğŸ” Secret: ${swapOrder.secret}`);
            console.log(`â° ETH Timelock: ${new Date(swapOrder.ethTimelock * 1000).toISOString()}`);
            console.log(`â° SUI Timelock: ${new Date(swapOrder.suiTimelock * 1000).toISOString()}\n`);

            // Step 1: Create Ethereum Atomic Swap Order
            console.log("ğŸ“‹ Step 1: Creating Ethereum Atomic Swap Order...");
            const ethOrderResult = await this.createEthereumAtomicSwapOrder(
                swapOrder.orderId,
                ethReceiverAddress,
                swapOrder.hashlock,
                swapOrder.ethTimelock,
                swapOrder.makerAsset,
                swapOrder.takerAsset,
                swapOrder.makerAmount,
                swapOrder.takerAmount,
                swapOrder.orderData,
                swapOrder.signature
            );

            // Step 2: Create Sui HTLC
            console.log("\nğŸ“‹ Step 2: Creating Sui HTLC...");
            const suiHtlcResult = await this.createSuiHTLC(
                swapOrder.orderId,
                suiReceiverAddress,
                swapOrder.hashlock,
                swapOrder.suiTimelock,
                suiAmount
            );

            // Wait for Sui transaction finalization
            console.log("â³ Waiting for Sui HTLC transaction to be finalized...");
            await this.suiClient.waitForTransaction({
                digest: suiHtlcResult.digest
            });
            console.log("âœ… Sui HTLC transaction finalized!");

            // Step 3: Claim Sui HTLC (reveals secret)
            console.log("\nğŸ“‹ Step 3: Claiming Sui HTLC (revealing secret)...");
            const suiClaimResult = await this.claimSuiHTLC(
                swapOrder.orderId,
                swapOrder.secret,
                swapOrder.hashlock,
                suiHtlcResult.digest
            );

            // Step 4: Fill Ethereum Atomic Swap Order (using revealed secret)
            console.log("\nğŸ“‹ Step 4: Filling Ethereum Atomic Swap Order...");
            const ethFillResult = await this.fillAtomicSwapOrder(
                swapOrder.orderId,
                swapOrder.secret,
                "0x", // Empty interaction data
                swapOrder.makerAmount,
                swapOrder.takerAmount,
                swapOrder.takerAmount // Use taker amount as threshold
            );

            console.log("\nğŸ‰ LIMIT ORDER ATOMIC SWAP COMPLETED SUCCESSFULLY! ğŸ‰");
            console.log("==========================================");
            console.log("ğŸ“Š Transaction Summary:");
            console.log(`ğŸ”— ETH Order Created: ${ethOrderResult.transactionHash}`);
            console.log(`ğŸ”— SUI HTLC Created: ${suiHtlcResult.digest}`);
            console.log(`ğŸ”— SUI HTLC Claimed: ${suiClaimResult.digest}`);
            console.log(`ğŸ”— ETH Order Filled: ${ethFillResult.transactionHash}`);
            console.log("==========================================");
            console.log("ğŸ”— All Transaction Hashes with Explorer Links:");
            console.log(`1ï¸âƒ£  ETH Order Creation: ${ethOrderResult.transactionHash}`);
            console.log(`    ğŸ” Explorer: https://etherscan.io/tx/${ethOrderResult.transactionHash}`);
            console.log(`2ï¸âƒ£  SUI HTLC Creation: ${suiHtlcResult.digest}`);
            console.log(`    ğŸ” Explorer: https://suiexplorer.com/txblock/${suiHtlcResult.digest}?network=mainnet`);
            console.log(`3ï¸âƒ£  SUI HTLC Claim: ${suiClaimResult.digest}`);
            console.log(`    ğŸ” Explorer: https://suiexplorer.com/txblock/${suiClaimResult.digest}?network=mainnet`);
            console.log(`4ï¸âƒ£  ETH Order Fill: ${ethFillResult.transactionHash}`);
            console.log(`    ğŸ” Explorer: https://etherscan.io/tx/${ethFillResult.transactionHash}`);
            console.log("==========================================");
            return true;

        } catch (error) {
            console.error("âŒ Error during limit order atomic swap:", error);
            throw error;
        }
    }
}

// Example usage
async function runLimitOrderExample() {
    console.log("ğŸš€ Starting Limit Order Atomic Swap Example...");
    const swap = new LimitOrderAtomicSwap();
    
    try {
        const suiSenderAddress = swap.getSuiAddress();
        console.log(`ğŸ“ Using SUI address: ${suiSenderAddress}`);
        
        await swap.performLimitOrderAtomicSwap(
            "0.00001", // ETH amount
            "0.00001", // SUI amount
            process.env.ETH_RECEIVER_ADDRESS || "0x0000000000000000000000000000000000000000",
            suiSenderAddress
        );
    } catch (error) {
        console.error("âŒ Limit Order Atomic Swap failed:", error);
    }
}

// Export for external use
export { LimitOrderAtomicSwap, runLimitOrderExample };

// Run the example if this file is run directly
if (require.main === module) {
    runLimitOrderExample().catch(console.error);
}
