import { ethers } from 'ethers';
import { JsonRpcProvider } from '@ethersproject/providers';
import * as crypto from 'crypto';
import { SuiClient, SuiTransactionBlockResponse } from '@mysten/sui/client';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { Transaction } from '@mysten/sui/transactions';
import { getFullnodeUrl } from '@mysten/sui/client';
import { bcs } from '@mysten/sui/bcs';
import dotenv from 'dotenv';

dotenv.config();

// Load configuration
const config = JSON.parse(require('fs').readFileSync('./config.json', 'utf8'));

// Limit Order Escrow ABI
const LIMIT_ORDER_ESCROW_ABI = [
    "function createAtomicSwapOrder(bytes32 orderId, address taker, address makerAsset, address takerAsset, uint256 makerAmount, uint256 takerAmount, bytes32 hashlock, uint256 timelock, bytes calldata orderData, bytes calldata signature) external payable",
    "function fillAtomicSwapOrder(bytes32 orderId, bytes32 secret, bytes calldata interaction, uint256 makingAmount, uint256 takingAmount, uint256 thresholdAmount) external",
    "function refundAtomicSwapOrder(bytes32 orderId) external",
    "function getAtomicSwapOrder(bytes32 orderId) external view returns (bytes32, bytes32, uint256, address, address, address, address, uint256, uint256, bytes32, bool, bool, uint256)",
    "function getRevealedSecret(bytes32 orderId) external view returns (bytes32)",
    "function authorizeRelayer(address relayer) external",
    "event AtomicSwapOrderCreated(bytes32 indexed orderId, address indexed maker, address indexed taker, address makerAsset, address takerAsset, uint256 makerAmount, uint256 takerAmount, bytes32 hashlock, uint256 timelock)",
    "event AtomicSwapOrderFilled(bytes32 indexed orderId, address indexed taker, bytes32 secret, uint256 makerAmount, uint256 takerAmount)",
    "event AtomicSwapOrderRefunded(bytes32 indexed orderId, address indexed maker, uint256 makerAmount)"
];

interface SwapOrder {
    orderId: string;
    secret: string;
    hashlock: string;
    ethTimelock: number;
    suiTimelock: number;
    makerAsset: string;
    takerAsset: string;
    makerAmount: string;
    takerAmount: string;
    orderData: string;
    signature: string;
}

class LimitOrderAtomicSwap {
    private ethProvider: JsonRpcProvider;
    private ethWallet: ethers.Wallet;
    private ethContract: ethers.Contract;
    private suiClient: SuiClient;
    private suiKeypair: Ed25519Keypair;

    constructor() {
        // Initialize Ethereum
        this.ethProvider = new JsonRpcProvider(config.ethereum.rpc);
        this.ethWallet = new ethers.Wallet(config.ethereum.privateKey, this.ethProvider);
        this.ethContract = new ethers.Contract(
            config.ethereum.limitOrderEscrowAddress,
            LIMIT_ORDER_ESCROW_ABI,
            this.ethWallet
        );

        // Initialize Sui
        this.suiClient = new SuiClient({ url: getFullnodeUrl('mainnet') });
        const privateKey = config.sui.privateKey.endsWith('1b') ? 
            config.sui.privateKey.slice(0, -2) : config.sui.privateKey;
        this.suiKeypair = Ed25519Keypair.fromSecretKey(Buffer.from(privateKey, 'hex'));
        
        console.log("üîó Limit Order Atomic Swap initialized");
        console.log(`üìç ETH Address: ${this.ethWallet.address}`);
        console.log(`üìç SUI Address: ${this.suiKeypair.getPublicKey().toSuiAddress()}`);
    }

    getSuiAddress(): string {
        return this.suiKeypair.getPublicKey().toSuiAddress();
    }

    private generateSwapOrder(): SwapOrder {
        const secret = crypto.randomBytes(32);
        const hashlock = crypto.createHash('sha256').update(secret).digest();
        const orderId = crypto.randomBytes(16).toString('hex');
        const ethTimelock = Math.floor(Date.now() / 1000) + 7200; // 2 hours
        const suiTimelock = Math.floor(Date.now() / 1000) + 3600; // 1 hour

        // Generate mock 1inch order data and signature
        // In production, this would be generated by the 1inch SDK
        const orderData = "0x" + crypto.randomBytes(100).toString('hex');
        const signature = "0x" + crypto.randomBytes(65).toString('hex');

        return {
            orderId,
            secret: "0x" + secret.toString('hex'),
            hashlock: "0x" + Buffer.from(hashlock).toString('hex'),
            ethTimelock,
            suiTimelock,
            makerAsset: config.ethereum.weth, // WETH as maker asset
            takerAsset: "0x0000000000000000000000000000000000000000", // ETH as taker asset
            makerAmount: ethers.utils.parseEther("0.00001").toString(), // 0.001 WETH
            takerAmount: ethers.utils.parseEther("0.00001").toString(), // 0.001 ETH
            orderData,
            signature
        };
    }

    async createEthereumAtomicSwapOrder(
        orderId: string,
        takerAddress: string,
        hashlock: string,
        timelock: number,
        makerAsset: string,
        takerAsset: string,
        makerAmount: string,
        takerAmount: string,
        orderData: string,
        signature: string
    ) {
        console.log("üîó Creating Ethereum Atomic Swap Order...");
        console.log(`üìù Order ID: ${orderId}`);
        console.log(`üí∞ Maker Amount: ${ethers.utils.formatEther(makerAmount)} WETH`);
        console.log(`üí∞ Taker Amount: ${ethers.utils.formatEther(takerAmount)} ETH`);
        console.log(`‚è∞ Timelock: ${new Date(timelock * 1000).toISOString()}`);
        
        // First approve WETH spending
        const wethContract = new ethers.Contract(
            config.ethereum.weth,
            ["function approve(address spender, uint256 amount) external returns (bool)"],
            this.ethWallet
        );
        
        console.log("üîì Approving WETH spending...");
        const approveTx = await wethContract.approve(
            config.ethereum.limitOrderEscrowAddress,
            makerAmount,
            { gasLimit: 100000 }
        );
        await approveTx.wait();
        console.log("‚úÖ WETH approved");
        
        const tx = await this.ethContract.createAtomicSwapOrder(
            ethers.utils.id(orderId),
            takerAddress,
            makerAsset,
            takerAsset,
            makerAmount,
            takerAmount,
            hashlock,
            timelock,
            orderData,
            signature,
            { gasLimit: 500000 }
        );
        
        console.log(`‚è≥ Transaction pending: ${tx.hash}`);
        const receipt = await tx.wait();
        
        console.log("‚úÖ Ethereum Atomic Swap Order created successfully!");
        console.log(`üîó Transaction Hash: ${receipt.transactionHash}`);
        console.log(`üîç Explorer: https://sepolia.etherscan.io/tx/${receipt.transactionHash}`);
        console.log(`‚õΩ Gas Used: ${receipt.gasUsed.toString()}`);
        
        return receipt;
    }

    async createSuiHTLC(htlcId: string, receiverAddress: string, hashlock: string, timelock: number, amount: string) {
        console.log("\nüîó Creating Sui HTLC...");
        console.log(`üìù HTLC ID: ${htlcId}`);
        console.log(`üí∞ Amount: ${amount} SUI`);
        console.log(`‚è∞ Timelock: ${new Date(timelock * 1000).toISOString()}`);
        
        const senderAddress = this.suiKeypair.getPublicKey().toSuiAddress();
        console.log(`üë§ Receiver: ${receiverAddress}`);
        
        // Get coins for payment
        const coins = await this.suiClient.getCoins({
            owner: senderAddress,
            coinType: "0x2::sui::SUI"
        });
        
        if (!coins || coins.data.length === 0) {
            throw new Error("‚ùå No SUI coins found in wallet");
        }

        const tx = new Transaction();
        const amountInMist = Math.floor(parseFloat(amount) * 1e9);
        const [paymentCoin] = tx.splitCoins(tx.gas, [tx.pure.u64(amountInMist)]);

        const htlcIdBytes = Array.from(Buffer.from(htlcId));
        const hashlockBytes = Array.from(Buffer.from(hashlock.slice(2), 'hex'));
        const receiverAddr = receiverAddress.replace('0x', '');

        tx.moveCall({
            target: `${config.sui.packageId}::htlc::create_htlc`,
            arguments: [
                tx.object.clock(),
                tx.pure.vector('u8', htlcIdBytes),
                tx.pure.address(receiverAddr),
                tx.pure.vector('u8', hashlockBytes),
                tx.pure.u64(timelock),
                paymentCoin
            ]
        });

        const result = await this.suiClient.signAndExecuteTransaction({
            signer: this.suiKeypair,
            transaction: tx,
            options: { 
                showEffects: true,
                gasBudget: 100000000
            }
        });
        
        console.log("‚úÖ Sui HTLC created successfully!");
        console.log(`üîó Transaction Hash: ${result.digest}`);
        console.log(`üîç Explorer: https://suiexplorer.com/txblock/${result.digest}?network=testnet`);
        
        return result;
    }

    async fillAtomicSwapOrder(
        orderId: string,
        secret: string,
        interaction: string,
        makingAmount: string,
        takingAmount: string,
        thresholdAmount: string
    ) {
        console.log("üîì Filling Atomic Swap Order...");
        console.log(`üìù Order ID: ${orderId}`);
        console.log(`üîê Secret: ${secret}`);
        console.log(`üí∞ Taking Amount (ETH): ${ethers.utils.formatEther(takingAmount)}`);
        
        const tx = await this.ethContract.fillAtomicSwapOrder(
            ethers.utils.id(orderId),
            secret,
            interaction,
            makingAmount,
            takingAmount,
            thresholdAmount,
            { 
                value: takingAmount, // Send ETH as taker
                gasLimit: 500000 
            }
        );
        
        console.log(`‚è≥ Transaction pending: ${tx.hash}`);
        const receipt = await tx.wait();
        
        console.log("‚úÖ Atomic Swap Order filled successfully!");
        console.log(`üîó Transaction Hash: ${receipt.transactionHash}`);
        console.log(`üîç Explorer: https://sepolia.etherscan.io/tx/${receipt.transactionHash}`);
        
        return receipt;
    }

    async claimSuiHTLC(htlcId: string, secret: string, hashlock: string, htlcTxDigest: string) {
        console.log("üîì Claiming Sui HTLC...");
        console.log(`üìù HTLC ID: ${htlcId}`);
        console.log(`üîê Secret: ${secret}`);
        
        const tx = new Transaction();
        
        // Get HTLC object from transaction
        const htlcTx = await this.suiClient.getTransactionBlock({
            digest: htlcTxDigest,
            options: {
                showEffects: true,
                showObjectChanges: true
            }
        });

        const htlcObject = htlcTx.objectChanges.find(change => 
            change.type === 'created' && 
            change.objectType.includes('::htlc::HTLC')
        );

        if (!htlcObject) {
            throw new Error("‚ùå HTLC object not found in transaction");
        }

        const secretBytes = Array.from(Buffer.from(secret.slice(2), 'hex'));
        
        tx.moveCall({
            target: `${config.sui.packageId}::htlc::claim_with_secret`,
            arguments: [
                tx.object.clock(),
                tx.object(htlcObject.objectId),
                tx.pure.vector('u8', secretBytes)
            ]
        });
        
        const result = await this.suiClient.signAndExecuteTransaction({
            signer: this.suiKeypair,
            transaction: tx,
            options: { 
                showEffects: true,
                gasBudget: 100000000
            }
        });
        
        console.log("‚úÖ Sui HTLC claimed successfully!");
        console.log(`üîó Transaction Hash: ${result.digest}`);
        console.log(`üîç Explorer: https://suiexplorer.com/txblock/${result.digest}?network=testnet`);
        
        return result;
    }

    async performLimitOrderAtomicSwap(
        ethAmount: string,
        suiAmount: string,
        ethReceiverAddress: string,
        suiReceiverAddress: string
    ): Promise<boolean> {
        try {
            console.log("\nüöÄ Starting Limit Order Atomic Swap...");
            console.log("=====================================");
            console.log(`üí∞ ETH Amount: ${ethAmount}`);
            console.log(`üí∞ SUI Amount: ${suiAmount}`);
            console.log(`üë§ ETH Receiver: ${ethReceiverAddress}`);
            console.log(`üë§ SUI Receiver: ${suiReceiverAddress}`);
            console.log("=====================================\n");
            
            // Generate swap order with 1inch integration
            const swapOrder = this.generateSwapOrder();
            console.log("üé≤ Generated swap order:");
            console.log(`üìù Order ID: ${swapOrder.orderId}`);
            console.log(`üîê Hashlock: ${swapOrder.hashlock}`);
            console.log(`üîê Secret: ${swapOrder.secret}`);
            console.log(`‚è∞ ETH Timelock: ${new Date(swapOrder.ethTimelock * 1000).toISOString()}`);
            console.log(`‚è∞ SUI Timelock: ${new Date(swapOrder.suiTimelock * 1000).toISOString()}\n`);

            // Step 1: Create Ethereum Atomic Swap Order
            console.log("üìã Step 1: Creating Ethereum Atomic Swap Order...");
            const ethOrderResult = await this.createEthereumAtomicSwapOrder(
                swapOrder.orderId,
                ethReceiverAddress,
                swapOrder.hashlock,
                swapOrder.ethTimelock,
                swapOrder.makerAsset,
                swapOrder.takerAsset,
                swapOrder.makerAmount,
                swapOrder.takerAmount,
                swapOrder.orderData,
                swapOrder.signature
            );

            // Step 2: Create Sui HTLC
            console.log("\nüìã Step 2: Creating Sui HTLC...");
            const suiHtlcResult = await this.createSuiHTLC(
                swapOrder.orderId,
                suiReceiverAddress,
                swapOrder.hashlock,
                swapOrder.suiTimelock,
                suiAmount
            );

            // Wait for Sui transaction finalization
            console.log("‚è≥ Waiting for Sui HTLC transaction to be finalized...");
            await this.suiClient.waitForTransaction({
                digest: suiHtlcResult.digest
            });
            console.log("‚úÖ Sui HTLC transaction finalized!");

            // Step 3: Claim Sui HTLC (reveals secret)
            console.log("\nüìã Step 3: Claiming Sui HTLC (revealing secret)...");
            const suiClaimResult = await this.claimSuiHTLC(
                swapOrder.orderId,
                swapOrder.secret,
                swapOrder.hashlock,
                suiHtlcResult.digest
            );

            // Step 4: Fill Ethereum Atomic Swap Order (using revealed secret)
            console.log("\nüìã Step 4: Filling Ethereum Atomic Swap Order...");
            const ethFillResult = await this.fillAtomicSwapOrder(
                swapOrder.orderId,
                swapOrder.secret,
                "0x", // Empty interaction data
                swapOrder.makerAmount,
                swapOrder.takerAmount,
                swapOrder.takerAmount // Use taker amount as threshold
            );

            console.log("\nüéâ LIMIT ORDER ATOMIC SWAP COMPLETED SUCCESSFULLY! üéâ");
            console.log("==========================================");
            console.log("üìä Transaction Summary:");
            console.log(`üîó ETH Order Created: ${ethOrderResult.transactionHash}`);
            console.log(`üîó SUI HTLC Created: ${suiHtlcResult.digest}`);
            console.log(`üîó SUI HTLC Claimed: ${suiClaimResult.digest}`);
            console.log(`üîó ETH Order Filled: ${ethFillResult.transactionHash}`);
            console.log("==========================================");
            console.log("üîó All Transaction Hashes with Explorer Links:");
            console.log(`1Ô∏è‚É£  ETH Order Creation: ${ethOrderResult.transactionHash}`);
            console.log(`    üîç Explorer: https://etherscan.io/tx/${ethOrderResult.transactionHash}`);
            console.log(`2Ô∏è‚É£  SUI HTLC Creation: ${suiHtlcResult.digest}`);
            console.log(`    üîç Explorer: https://suiexplorer.com/txblock/${suiHtlcResult.digest}?network=mainnet`);
            console.log(`3Ô∏è‚É£  SUI HTLC Claim: ${suiClaimResult.digest}`);
            console.log(`    üîç Explorer: https://suiexplorer.com/txblock/${suiClaimResult.digest}?network=mainnet`);
            console.log(`4Ô∏è‚É£  ETH Order Fill: ${ethFillResult.transactionHash}`);
            console.log(`    üîç Explorer: https://etherscan.io/tx/${ethFillResult.transactionHash}`);
            console.log("==========================================");
            return true;

        } catch (error) {
            console.error("‚ùå Error during limit order atomic swap:", error);
            throw error;
        }
    }
}

// Example usage
async function runLimitOrderExample() {
    console.log("üöÄ Starting Limit Order Atomic Swap Example...");
    const swap = new LimitOrderAtomicSwap();
    
    try {
        const suiSenderAddress = swap.getSuiAddress();
        console.log(`üìç Using SUI address: ${suiSenderAddress}`);
        
        await swap.performLimitOrderAtomicSwap(
            "0.00001", // ETH amount
            "0.00001", // SUI amount
            process.env.ETH_RECEIVER_ADDRESS || "0x0000000000000000000000000000000000000000",
            suiSenderAddress
        );
    } catch (error) {
        console.error("‚ùå Limit Order Atomic Swap failed:", error);
    }
}

// Export for external use
export { LimitOrderAtomicSwap, runLimitOrderExample };

// Run the example if this file is run directly
if (require.main === module) {
    runLimitOrderExample().catch(console.error);
}
